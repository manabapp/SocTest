/* 
  Localizable.strings
  SocTest

  Created by Hirose Manabu on 2021/01/31.
  
*/

ToS_Title = "Terms of Service";
ToS_Agree = "Agree";

Message_Copied_to_clipboard = "Copied to clipboard.";
Message_Data_saving_done = "Data saving done.";
Message_FileOpenError = "Could not save to file.";
Message_FileDeleteError = "Could not delete file.";
Message_NoValue = "No value.";
Message_NoName = "No name.";
Message_NoData = "No data selected.";
Message_TooLongPath = "Path too long.";
Message_TooLongName = "Name too long.";
Message_TooLargeData = "Data size too large.";
Message_InvalidValue = "Invalid value.";
Message_InvalidIndex = "Invalid index.";
Message_InvalidIpAddr = "Invalid IP address format.";
Message_InvalidPort = "Invalid port value.";
Message_InvalidPath = "Invalid address format.";
Message_InvalidName = "Invalid name.";
Message_InvalidHexCode = "Non-hex code included.";
Message_AlreadyAddressExist = "Already same address exists.";
Message_AlreadyNameExist = "Already same name exists.";
Message_AlreadySaved = "Already this data saved.";
Message_AddressExceeded = "Maximum number of addresses exceeded.";
Message_IODataExceeded = "Maximum number of data exceeded.";
Message_CantOpenURL = "Can't open the Internet site.";
Message_default = "Internal error.";

Strerror_DUMMY = "Dummy";
Strerror_EPERM = "Operation not permitted";
Strerror_ENOENT = "No such file or directory";
Strerror_ESRCH = "No such process";
Strerror_EINTR = "Interrupted system call";
Strerror_EIO = "Input/output error";
Strerror_ENXIO = "Device not configured";
Strerror_E2BIG = "Argument list too long";
Strerror_ENOEXEC = "Exec format error";
Strerror_EBADF = "Bad file descriptor";
Strerror_ECHILD = "No child processes";
Strerror_EDEADLK = "Resource deadlock avoided";
Strerror_ENOMEM = "Cannot allocate memory";
Strerror_EACCES = "Permission denied";
Strerror_EFAULT = "Bad address";
Strerror_ENOTBLK = "Block device required";
Strerror_EBUSY = "Resource busy";
Strerror_EEXIST = "File exists";
Strerror_EXDEV = "Cross-device link";
Strerror_ENODEV = "Operation not supported by device";
Strerror_ENOTDIR = "Not a directory";
Strerror_EISDIR = "Is a directory";
Strerror_EINVAL = "Invalid argument";
Strerror_ENFILE = "Too many open files in system";
Strerror_EMFILE = "Too many open files";
Strerror_ENOTTY = "Inappropriate ioctl for device";
Strerror_ETXTBSY = "Text file busy";
Strerror_EFBIG = "File too large";
Strerror_ENOSPC = "No space left on device";
Strerror_ESPIPE = "Illegal seek";
Strerror_EROFS = "Read-only file system";
Strerror_EMLINK = "Too many links";
Strerror_EPIPE = "Broken pipe";
Strerror_EDOM = "Numerical argument out of domain";
Strerror_ERANGE = "Result too large";
Strerror_EAGAIN = "Resource temporarily unavailable";
Strerror_EWOULDBLOCK = "Operation would block";  //alias
Strerror_EINPROGRESS = "Operation now in progress";
Strerror_EALREADY = "Operation already in progress";
Strerror_ENOTSOCK = "Socket operation on non-socket";
Strerror_EDESTADDRREQ = "Destination address required";
Strerror_EMSGSIZE = "Message too long";
Strerror_EPROTOTYPE = "Protocol wrong type for socket";
Strerror_ENOPROTOOPT = "Protocol not available";
Strerror_EPROTONOSUPPORT = "Protocol not supported";
Strerror_ESOCKTNOSUPPORT = "Socket type not supported";
Strerror_ENOTSUP = "Operation not supported";
Strerror_EPFNOSUPPORT = "Protocol family not supported";
Strerror_EAFNOSUPPORT = "Address family not supported by protocol family";
Strerror_EADDRINUSE = "Address already in use";
Strerror_EADDRNOTAVAIL = "Can't assign requested address";
Strerror_ENETDOWN = "Network is down";
Strerror_ENETUNREACH = "Network is unreachable";
Strerror_ENETRESET = "Network dropped connection on reset";
Strerror_ECONNABORTED = "Software caused connection abort";
Strerror_ECONNRESET = "Connection reset by peer";
Strerror_ENOBUFS = "No buffer space available";
Strerror_EISCONN = "Socket is already connected";
Strerror_ENOTCONN = "Socket is not connected";
Strerror_ESHUTDOWN = "Can't send after socket shutdown";
Strerror_ETOOMANYREFS = "Too many references: can't splice";
Strerror_ETIMEDOUT = "Operation timed out";
Strerror_ECONNREFUSED = "Connection refused";
Strerror_ELOOP = "Too many levels of symbolic links";
Strerror_ENAMETOOLONG = "File name too long";
Strerror_EHOSTDOWN = "Host is down";
Strerror_EHOSTUNREACH = "No route to host";
Strerror_ENOTEMPTY = "Directory not empty";
Strerror_EPROCLIM = "Too many processes";
Strerror_EUSERS = "Too many users";
Strerror_EDQUOT = "Disc quota exceeded";
Strerror_ESTALE = "Stale NFS file handle";
Strerror_EREMOTE = "Too many levels of remote in path";
Strerror_EBADRPC = "RPC struct is bad";
Strerror_ERPCMISMATCH = "RPC version wrong";
Strerror_EPROGUNAVAIL = "RPC prog. not avail";
Strerror_EPROGMISMATCH = "Program version wrong";
Strerror_EPROCUNAVAIL = "Bad procedure for program";
Strerror_ENOLCK = "No locks available";
Strerror_ENOSYS = "Function not implemented";
Strerror_EFTYPE = "Inappropriate file type or format";
Strerror_EAUTH = "Authentication error";
Strerror_ENEEDAUTH = "Need authenticator";
Strerror_EPWROFF = "Device power is off";
Strerror_EDEVERR = "Device error";
Strerror_EOVERFLOW = "Value too large to be stored in data type";
Strerror_EBADEXEC = "Bad executable (or shared library)";
Strerror_EBADARCH = "Bad CPU type in executable";
Strerror_ESHLIBVERS = "Shared library version mismatch";
Strerror_EBADMACHO = "Malformed Mach-o file";
Strerror_ECANCELED = "Operation canceled";
Strerror_EIDRM = "Identifier removed";
Strerror_ENOMSG = "No message of desired type";
Strerror_EILSEQ = "Illegal byte sequence";
Strerror_ENOATTR = "Attribute not found";
Strerror_EBADMSG = "Bad message";
Strerror_EMULTIHOP = "Reserved";
Strerror_ENODATA = "No message available on STREAM";
Strerror_ENOLINK = "Reserved";
Strerror_ENOSR = "No STREAM resources";
Strerror_ENOSTR = "Not a STREAM";
Strerror_EPROTO = "Protocol error";
Strerror_ETIME = "STREAM ioctl timeout";
Strerror_EOPNOTSUPP = "Operation not supported on socket";
Strerror_ENOPOLICY = "Policy not found";
Strerror_ENOTRECOVERABLE = "State not recoverable";
Strerror_EOWNERDEAD = "Previous owner died";
Strerror_EQFULL = "Interface output queue is full";
Strerror_ELAST = "Must be equal largest errno";

Button_Done = "Done";
Button_OK = "OK";
Button_Set = "Set";
Button_Save = "Save";
Button_Save2 = "Save";
Button_Convert = "Convert";
Button_Convert2 = "Convert";
Button_Register = "Register";
Button_Reload = "Reload";
Button_Reload2 = "Reload";
Button_Copy = "Copy";
Button_Copy2 = "Copy";
Button_Clear = "Clear";  // no use
Button_Clear2 = "Clear";

Description_Without_address = "Sends without specifying address";
Description_Clear_options = "Clears previously specified options";
Description_No_address = "No address is registered";
Description_No_data = "No data is registered";
Description_socket = "Creates new socket";
Description_setsockopt = "Gets / sets the value of the given socket option";
Description_bind = "Binds a address to the socket";
Description_connect = "Connects the socket to a remote address";
Description_listen = "Enables a server to accept connections";
Description_accept = "Accepts a connection via bound and listening socket";
Description_send = "Sends data to the socket";
Description_sendto = "Sends data to the socket";
Description_sendmsg = "Sends normal and ancillary data to the socket";
Description_recv = "Receives data from the socket";
Description_recvfrom = "Receives data from the socket";
Description_recvmsg = "Receives normal and ancillary data from the socket";
Description_getsockname = "Gets the socketâ€™s own address";
Description_getpeername = "Gets remote address to which the socket is connected";
Description_shutdown = "Shuts down one or both halves of the connection";
Description_fcntl = "Sets non-blocking mode of the socket";
Description_poll = "Waits for the socket to become ready to send/recv";
Description_close = "Closes the socket";
Description_SHUT_RD = "Disallows further receptions (Shuts down part of conn)";
Description_SHUT_WR = "Disallows further transmissions (Shuts down part of conn)";
Description_SHUT_RDWR = "Disallows both (Shuts down all of full-duplex connection)";
Description_POLLIN = "There is receivable data or request for connection";
Description_POLLPRI = "There is some exceptional condition (Urgent data)";
Description_POLLOUT = "Sending is now possible";
Description_POLLERR = "An exceptional condition has occurred on socket (output only)";
Description_POLLHUP = "The socket has been disconnected (output only)";
Description_POLLNVAL = "The file descriptor is not opened (output only)";
Description_pollTimerNo = "Blocks indefinitely until any event";
Description_pollTimer0 = "Returns immediately without blocking";
Description_SO_DEBUG = "Enables recording of debugging information";
Description_SO_ACCEPTCONN = "Whether the socket is listening";
Description_SO_REUSEADDR = "Enables local address reuse";
Description_SO_KEEPALIVE = "Enables keep connections alive";
Description_SO_DONTROUTE = "Enables routing bypass for outgoing messages";
Description_SO_BROADCAST = "Enables permission to transmit broadcast messages";
Description_SO_USELOOPBACK = "Enables communication by bypassing hardware";
Description_SO_LINGER = "Linger on close if data present";
Description_SO_OOBINLINE = "Enables reception of out-of-band data in band";
Description_SO_REUSEPORT = "Enables bind the same port by multiple processes";
Description_SO_TIMESTAMP = "Enables reciept of timestamp as a control message";
Description_SO_TIMESTAMP_MONOTONIC = "Enables reciept of monotonically increasing timestamp as a control message";
Description_SO_SNDBUF = "Buffer size for output";
Description_SO_RCVBUF = "Buffer size for input";
Description_SO_SNDLOWAT = "Minimum count for output";
Description_SO_RCVLOWAT = "Minimum count for input";
Description_SO_SNDTIMEO = "Timeout value for output";
Description_SO_RCVTIMEO = "Timeout value for input";
Description_SO_ERROR = "Gets and clears error on the socket";
Description_SO_TYPE = "Socket type";
Description_SO_NUMRCVPKT = "Number of datagrams in receive socket buffer";
Description_SO_NET_SERVICE_TYPE = "Network service type";
Description_SO_NETSVC_MARKING_LEVEL = "QoS marking in effect for socket";
Description_TCP_NODELAY = "Segments always sent ASAP";
Description_TCP_MAXSEG = "Maximum segment size for outgoing TCP packets";
Description_TCP_NOOPT = "Disables TCP option";
Description_TCP_NOPUSH = "Disables immediately sending data with PUSH bit";
Description_TCP_KEEPALIVE = "Idle time before keep-alive probes are sent";
Description_TCP_CONNECTIONTIMEOUT = "Timeout value for connection";
Description_TCP_RXT_CONNDROPTIME = "Time after which TCP retransmission will be stopped";
Description_TCP_RXT_FINDROP = "Drops connection after retransmitting FIN 3 times";
Description_TCP_KEEPINTVL = "Time between individual keep-alive probes";
Description_TCP_KEEPCNT = "Maximum number of keep-alive probes";
Description_TCP_SENDMOREACKS = "Sends a TCP acknowledgement for every data";
Description_TCP_ENABLE_ECN = "Uses explicit congestion notification (ECN)";
Description_TCP_FASTOPEN = "Requests kernel to use TFO for the server socket";
Description_TCP_CONNECTION_INFO = "Gets TCP connection level statistics";
Description_TCP_NOTSENT_LOWAT = "Unsent and unacknowledged data size in send buffer";
Description_UDP_NOCKSUM = "Don't checksum outbound payloads";
Description_IP_OPTIONS = "Gets, sets, or clears IP options";
Description_IP_HDRINCL = "Suppress including IP header by kernel";
Description_IP_TOS = "Sets the type-of-service field in IP header";
Description_IP_TTL = "Sets the time-to-live field in IP header";
Description_IP_RECVOPTS = "Enables reciept of all IP options as a control message";
Description_IP_RECVRETOPTS = "Enables reciept of IP options as a control message for response";
Description_IP_RECVDSTADDR = "Enables reciept of destination IP address as a control message";
Description_IP_RETOPTS = "Enables sending / reciept of IP options as a control message";
Description_IP_MULTICAST_IF = "Sets the IP address of interface which multicast datagram is sent";
Description_IP_MULTICAST_TTL = "Changes the TTL for outgoing multicast datagrams";
Description_IP_MULTICAST_LOOP = "Enables looped back by the IP layer for local delivery";
Description_IP_ADD_MEMBERSHIP = "Joins a multicast group";
Description_IP_DROP_MEMBERSHIP = "Drops a multicast group membership";
Description_IP_PORTRANGE = "Sets the range of local port numbers";
Description_IP_RECVIF = "Enables reciept of interface which datagram is receibed";
Description_IP_STRIPHDR = "Drops receive of raw IP header";
Description_IP_RECVTTL = "Enables reciept of TTL as a control message";
Description_IP_BOUND_IF = "Gets / sets bound interface";
Description_IP_PKTINFO = "Enables sending / reciept of pktinfo as a control message";
Description_IP_RECVTOS = "Enables reciept of TOS as a control message";
Description_IP_DONTFRAG = "Don't fragment packet";
Description_contentsCustom = "User data customized in Data Manager";
Description_contentsAllZeroDigit = "All \"0\" (0x30) string";
Description_contentsDigit = "Continuous numeric ascii string";
Description_contentsRandomDigit = "Random numeric ascii string";
Description_contentsRandomAlphaDigit = "Random apphabet & numeric ascii string";
Description_contentsRandomPrintable = "Random printable ascii string";
Description_contentsAllZeroBinary = "All 0 (0x00) binary code";
Description_contentsAllOneBinary = "All 1 (0xff) binary code";
Description_contentsRandomBinary = "Random binay code";
Description_Control_SCM_RIGHTS = "Sends the open file descriptors via UNIX domain socket";
Description_Control_SCM_CREDS = "Sends the UNIX credentials of process via UNIX domain socket";
Description_Control_IP_RETOPTS = "Sends a packet with specifyied IP options";
Description_Control_IP_PKTINFO = "Specifies interface and address informaiton for looking routing table";
Description_MSG_OOB = "Sends out-of-band data (Send) / Requests receipt of oob data (Recv) / Indicates receipt of oob data (Msg)";
Description_MSG_DONTROUTE = "Sends to hosts only on directly connected networks (Send)";
Description_MSG_PEEK = "Requests to return data without removing data from receive queue (Recv)";
Description_MSG_WAITALL = "Requests that operation block until receiving full data (Recv)";
Description_MSG_TRUNC = "Indicates that the trailing part of data was discarded because data was larger than buffer (Msg)";
Description_MSG_CTRUNC = "Indicates that some control data were discarded because ancillary data buffer was lack (Msg)";
Description_Menu_App_Setting = "Changes setting for app operating & user interface";
Description_Menu_Log_Viewer = "Displays the system calls trace and the app's error log";
Description_Menu_About_App = "App's version information";
Description_Menu_errno = "Error number and corresponded messages in iOS";
Description_Menu_man = "Manuals for Socket API (Link to the Internet site)";
Description_Menu_Help = "Users guide for app (Link to the Internet site)";
Description_Menu_Privacy_Policy = "Privacy policy for app (Link to the Internet site)";
Description_Menu_Terms_of_Service = "App terms of service (Link to the Internet site)";

Description_Next_IpOptionsSetting = "Go to setting view for IP Options";
Description_New_BufferSize = "Go to setting view for Buffer Size";
Description_Next_MsgFlags = "Go to setting view for Message Flags";
Description_Go_back_Top = "Backs to top view";
Description_Full_Screen = "Displayes ASCII or HEX data on full screen";
Description_RecvSave = "Saves data received from socket";
Description_New_Address = "Creates new addess";
Description_New_Data = "Creates new data";
Description_ConvertA2X = "Ascii to Hex conversion";
Description_ConvertX2A = "Hex to Ascii conversion";
Description_EditorSave = "Saves data updated by this editor";
Description_Wi-Fi = "Wi-Fi";
Description_Cellurar = "Cellurar";
Description_Personal_Hotspot = "Personal Hotspot";
Description_Loopback = "Loopback";
Description_No_such_interface_found = "No such interface found";
Description_IP_address_not_assigned = "IP address not assigned";
Description_ANY_address = "ANY address";
Description_Private_address = "Private address";
Description_UNIX_address = "UNIX domain address";
Description_Unknown_host = "Unknown host";

Label_byte = "byte";
Label_bytes = "bytes";
Label_packet = "packet";
Label_packets = "packets";
Label_sec = "sec";
Label_Socket_address = "Socket address";
Label_Peer_address = "Peer address";
Label_Placeholder_freeBacklog = "Range: 0 or upper";
Label_Obtains_an_address = "Obtains an address";
Label_Placeholder_freePeriod = "Range: 1-3600000";
Label_Returned_events = "Returned events: ";
Label_No_events = "No events";
Label_Timed_out = "Timed out";
Label_No_address = "No address";
Label_Non-unicode_character_data = "Non-unicode character data";
Label_PortRange_DEFAULT = "DEFAULT";
Label_PortRange_HIGH = "HIGH";
Label_PortRange_LOW = "LOW";
Label_IpMreq_multiaddr = "Multicast group:";
Label_IpMreq_interface = "Local interface:";
Label_Linger_timeout = "Linger timeout";
Label_Placeholder_freeSize = "Range: 1-65536";
Label_Placeholder_freeCSize = "Range: 0-65536";
Label_Placeholder_fds = "File discriptors (Comma separated)";
Label_Destination_address = "Destination address";
Label_IP_options = "IP options";
Label_Interface_index = "Interface index (Index)";
Label_Local_address = "Local address";
Label_Enabled = "Enabled";
Label_Disabled = "Disabled";
Label_Inverted = "Inverted";
Label_IPv4_address = "IPv4 address";
Label_FQDN = "FQDN";
Label_IP_address = "IP address";
Label_Host_name = "Host name";
Label_Port_number = "Port number";
Label_UNIX_Path = "UNIX path";
Label_TRACE_Level1 = "Level 1";
Label_TRACE_Level2 = "Level 2";
Label_TRACE_Level3 = "Level 3";

Header_SOCKET_LIST = "SOCKET LIST";
Header_PROTOCOL_FAMILY = "PROTOCOL FAMILY";
Header_SOCKET_TYPE = "SOCKET TYPE";
Header_PROTOCOL = "PROTOCOL";
Header_SYSTEM_CALLS = "SYSTEM CALLS";
Header_SOCKET_ADDRESS = "SOCKET ADDRESS";
Header_DESTINATION_ADDRESS = "DESTINATION ADDRESS";
Header_BACKLOG = "BACKLOG";
Header_REMOTE_ADDRESS = "REMOTE ADDRESS";
Header_HOW = "HOW";
Header_TIMEOUT_PERIOD = "TIMEOUT PERIOD";
Header_REQUEST_EVENTS = "REQUEST EVENTS";
Header_SOL_SOCKET_OPTIONS = "SOL_SOCKET OPTIONS";
Header_IPPROTO_TCP_OPTIONS = "IPPROTO_TCP OPTIONS";
Header_IPPROTO_UDP_OPTIONS = "IPPROTO_UDP OPTIONS";
Header_IPPROTO_IP_OPTIONS = "IPPROTO_IP OPTIONS";
Header_DESTINATION_ADDRESS2 = "DESTINATION ADDRESS";
Header_REMOTE_ADDRESS2 = "REMOTE ADDRESS";
Header_DATA_CONTENTS = "DATA CONTENTS";
Header_DATA = "DATA";
Header_DATA_SIZE = "DATA SIZE";
Header_BUFFER_SIZE = "BUFFER SIZE";
Header_CONTROL_MESSAGES = "CONTROL MESSAGES";
Header_DATA_FOR_IP_OPTIONS = "DATA FOR IP OPTIONS";
Header_CONTROL_BUFFER_SIZE = "CONTROL MESSAGES BUFFER SIZE";
Header_MESSAGE_FLAGS = "MESSAGE FLAGS";
Header_INTERFACE_LIST = "INTERFACE LIST";
Header_ADDRESS_LIST = "ADDRESS LIST";
Header_ADDRESS_FAMILY = "ADDRESS FAMILY";
Header_ADDRESS = "ADDRESS";
Header_DATA_LIST = "DATA LIST";
Header_DATA_NAME = "DATA NAME";
Header_PREFERENCES = "PREFERENCES";
Header_LOG = "LOG";
Header_INFORMATION = "INFORMATION";
Header_LOCAL_ADDRESS = "LOCAL ADDRESS";
Header_BROADCAST_ADDRESS = "BROADCAST ADDRESS";
Header_MULTICAST_ADDRESS = "MULTICAST ADDRESS";
Header_UNICAST_ADDRESS = "UNICAST ADDRESS";

Footer_PROTOCOL_FAMILY = "PF_INET: IPv4 internet domain socket\nPF_UNIX: UNIX domain socket for local communication\n";
Footer_SOCKET_TYPE = "SOCK_STREAM: Connection-based byte streams socket\nSOCK_DGRAM: Connectionless datagrams socket\n";
Footer_PROTOCOL = "0: Default protocol supported on the protocol family and the socket type\nIPPROTO_TCP(6): Transmission Control Protocol\nIPPROTO_UDP(17): User Datagram Protocol\n";
Footer_REMOTE_ADDRESS = "Obtains the address of connection source host, reflected it into Top view.\n";
Footer_O_NONBLOCK = "If enables, changes the socket to non-blocking mode. If disables, back to blocking mode.\n";
Footer_REQUEST_EVENTS = "POLLERR, POLLHUP, and POLLNVAL are for output only.\n";
Footer_Option_NWService = "NET_SERVICE_TYPE_BE(0): Best effort\nNET_SERVICE_TYPE_BK(1): Background system initiated\nNET_SERVICE_TYPE_SIG(2): Signaling\nNET_SERVICE_TYPE_VI(3): Interactive Video\nNET_SERVICE_TYPE_VO(4): Interactive Voice\nNET_SERVICE_TYPE_RV(5): Responsive Multimedia Audio/Video\nNET_SERVICE_TYPE_AV(6): Multimedia Audio/Video Streaming\nNET_SERVICE_TYPE_OAM(7): Operations, Administration, and Management\nNET_SERVICE_TYPE_RD(8): Responsive Data\n";
Footer_Option_PortRange = "DEFAULT (IP_PORTRANGE_DEFAULT): 1024 - 5000\n HIGH (IP_PORTRANGE_HIGH): 49152 - 65535\nLOW (IP_PORTRANGE_LOW): 1024 - 1 (descending order)\n";
Footer_Option_InAddr = "Specifies the interface by IPv4 format address.\n";
Footer_Option_IpMreq = "Multicast group: Specifies the group to join (or leave) in IPv4 format (class D address).\nLocal interface: Specifies the IPv4 format address of a multicast enabled interface.\n";
Footer_Option_TcpConnInfo = "The check mark is highlighted when each flag of tcpi_tfo_* is turned ON.\n";
Footer_Option_OptionBool = "\n";
Footer_Option_OptionInt = "\n";
Footer_Option_OptionUsec = "Specifies the timeout value in seconds. The accuracy is microseconds (up to 6th decimal).\n";
Footer_Option_OptionUsec2 = "Specifies the timeout value in seconds. Decimal part is truncated.\n";
Footer_Option_OptionLinger = "If enabled, specifies the timeout value in seconds.\n";
Footer_REMOTE_ADDRESS2 = "Enables if wants to confirm the source address.\n";
Footer_CONTROL_MESSAGES = "For IP_RETOPTS and IP_PKTINFO, you must enable the socket option with setsockopt(2) in advance.\n";
Footer_SCM_RIGHTS = "Specifies the list of file descriptors separated by commas.\n";
Footer_IP_RETOPTS = "Specifies the member information of in_opts structure. Specifies the destination address in IPv4 format.\n";
Footer_IP_PKTINFO = "Specifies the member information of in_pktopt structure. You can find the interface index in Interface Configuration. Specifies the address in IPv4 format.\n";
Footer_MESSAGE_FLAGS = "Send: specifies flag with sendXXX(2)\nRecv: specifies flag with recvXXX(2)\nMsg: flag returned with recvmsg(2)\n";
Footer_INTERFACE_LIST = "Displays information equivalent to ifconfig command for network interfaces supported IPv4.\n";
Footer_ADDRESS_LIST = "AF_INET domain addresses and AF_UNIX domain addresses can be registered up to 32.\n";
Footer_ADDRESS_FAMILY = "\n";
Footer_HOST = "Specifies in FQDN format or IPv4 format as an IP address. Your device needs to be connected to the Internet for DNS name resolution. For FQDN format, can register only when name resolution is successful.\n\nIn order to register a private address (172.20.10.0/28) and communicate with the node on the local network, needs to enable the following settings on iOS device:\n - [Settings] > [SocTest] > [Local Network], or\n - [Settings] > [Privacy] > [Local Network] > [SocTest]\n";
Footer_PATH = "Available characters are alphanumeric, dot(.), hyphen(-) and underscore(_). Starts with alphanumeric, and path length is 100 charactors or less.\n\"UNIX path\" is relative path from the following directory.\n\n";
Footer_DATA_LIST = "Custom data and received data can be registered up to 32.\n";
Footer_DATA_NAME = "Available characters are alphanumeric, dot(.), hyphen(-) and underscore(_). Starts with alphanumeric, and path length is 32 charactors or less.\nData is saved under the following directory.\n\n";
Footer_DESCRIPTION = "Shows description article in each view.\n";
Footer_AUTO_MONITORING = "Monitors incoming data, connection status, and TCP state etc. If enabled, this app automatically call some system calls to check status after user operates each system call.\n";
Footer_IDLE_TIMER = "To avoid disconnection, turns off iOS's idle timer.\n";
Footer_SCREEN_COLOR = "Inverts the background color in data dump view.\nWhen disabled, matchs iOS device's appearance.\n";
Footer_SYSTEM_CALL_TRACE = "Selects the output level of system call trace. In send/recv system call, how to output transmitted/received data is as below.\n\nLevel 1: No data output\nLevel 2: First 16 bytes data is included into the line of system call\nLevel 3: Hex dump printed in addtion to system call\n";
Footer_DEBUG = "In addition to error log, App's debug log is output. By the way, the app always outputs error log.\nNote: This log is for this app developer.\n";
Header_MANUAL_LIST = "MANUAL LIST";
Header_ERROR_NUMBER_LIST = "ERROR NUMBER LIST";
